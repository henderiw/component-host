use core::fmt::{self, Debug};
use std::path::PathBuf;
use std::time::Instant;

use anyhow::{Context, Result};
use wasmtime::component::{Component, Linker};
use wasmtime::{Config, Engine, Store};
use wasmtime_wasi::{async_trait, WasiImpl};
use wasmtime_wasi::{ResourceTable, WasiCtx, WasiView};

mod bindings {
    //! Code generated by wasmtime component bindgen is sequestered to this module

    wasmtime::component::bindgen!({
        path: "../wit",
        world: "reconciler",
        async: true,
        with: {
            "wasi:io": wasmtime_wasi::bindings::io,
        },
    });
}

use bindings::{ReconcileError, ReconcileResult, Reconciler};

/// This state is used by the Runtime host,
/// we use it to store the WASI context (implementations of WASI)
/// and resource tables that components will use when executing
///
/// see:
/// - https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/trait.WasiView.html
/// - https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/fn.add_to_linker_sync.html
struct Ctx {
    wasi: WasiCtx,
    table: ResourceTable,
}

impl Ctx {
    pub fn new() -> Self {
        // NOTE: `inherit_env()` causes all the host environment variables to be visible to the host,
        // and if you use the WASI implementation provided (by wasmtime_wasi), all env vars would be
        // available to all components.
        //
        // What this code does (later in `main`) is control this exposure at *link* time, but
        // having the implementation filled by `Ctx` *not* the `Ctx#wasi` (which is a `WasiCtx`).
        //
        // This means that rather than go to the default code (provided by wasmtime_wasi), the linker hit the
        // implementation in this file attached to `Ctx`.
        //
        // If we knew we want to *never* use the underlying host's ENV, it would be a better idea to
        // remove the `inherit_env()` completely.
        //
        // The advantage of this setup is that you can have dynamic, filtered, or mediated access
        // to the host environment -- from the impl on `Ctx` -- this means that you could expose a filtered
        // list of environment variables that were available at host startup, nothing, or anything in between.
        //
        // You could do something like only allowing access to the full list of ENV variables *once* for a component,
        // and all you would need is some extra state on `Ctx`.
        //
        let wasi = WasiCtx::builder().inherit_stdio().inherit_env().build();
        Self {
            wasi,
            table: ResourceTable::new(),
        }
    }
}

impl Debug for Ctx {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Ctx").field("runtime", &"wasmtime").finish()
    }
}

impl WasiView for Ctx {
    fn table(&mut self) -> &mut ResourceTable {
        &mut self.table
    }

    fn ctx(&mut self) -> &mut WasiCtx {
        &mut self.wasi
    }
}


/// Custom implementation of *only* the environment bit of
/// wasi:cli, for our Host context object (`Ctx`)
impl wasmtime_wasi::bindings::cli::environment::Host for Ctx {
    fn get_environment(&mut self) -> wasmtime::Result<Vec<(String, String)>> {
        // Components will only ever get *this* list of environment variables
        Ok(vec![("STATIC".into(), "LIST!".into())])
    }

    fn get_arguments(&mut self) -> wasmtime::Result<Vec<String>> {
        todo!()
    }

    fn initial_cwd(&mut self) -> wasmtime::Result<Option<String>> {
        todo!()
    }
}

// NOTE: you need to use async_trait mostly because that's what the bindings use
//
// Unfortunately auto-complete/ cargo-expand will show you a trait *after* async_trait
// has had it's way with it -- so that's why you get obtusely named lifetimes and hard
// to read code for humans.
#[async_trait]
impl bindings::example::reconciler::retrieve::Host for Ctx {
    async fn get(&mut self, s: String) -> String {
        format!("Hello {s}!")
    }
}

/// load the WASM component and return the instance
async fn load_reconciler_instance(path: PathBuf) -> Result<(Store<Ctx>, bindings::Reconciler)> {
    // Initialize the Wasmtime engine
    let mut engine_config = Config::default();
    engine_config.async_support(true);
    engine_config.wasm_component_model(true);

    let engine = Engine::new(&engine_config).context("cannot create engine from config")?;

    // Load the WASM component
    let component = Component::from_file(&engine, &path).context("Component file not found")?;

    // Create the store to manage the state of the component
    let states: Ctx = Ctx::new();
    let mut store = Store::<Ctx>::new(&engine, states);

    // Set up the linker for linking interfaces
    let mut linker = Linker::new(&engine);
    let get_wasi_impl = type_annotate(|ctx| WasiImpl(ctx));
    let get_ctx = type_annotate_plain(|ctx| ctx);

    // Add WASI implementations (*execpt* environment) to the linker for components to use
    //
    // Rather than doing the below:
    // wasmtime_wasi::add_to_linker_async(&mut linker)
    //     .context("failed to link core WASI interfaces")?;
    //
    // We will add all the functionality *except* what we want to mock out
    wasmtime_wasi::bindings::clocks::wall_clock::add_to_linker_get_host(
        &mut linker,
        get_wasi_impl,
    )?;
    wasmtime_wasi::bindings::clocks::monotonic_clock::add_to_linker_get_host(
        &mut linker,
        get_wasi_impl,
    )?;
    wasmtime_wasi::bindings::filesystem::types::add_to_linker_get_host(&mut linker, get_wasi_impl)?;
    wasmtime_wasi::bindings::filesystem::preopens::add_to_linker_get_host(
        &mut linker,
        get_wasi_impl,
    )?;
    wasmtime_wasi::bindings::io::error::add_to_linker_get_host(&mut linker, get_wasi_impl)?;
    wasmtime_wasi::bindings::io::poll::add_to_linker_get_host(&mut linker, get_wasi_impl)?;
    wasmtime_wasi::bindings::io::streams::add_to_linker_get_host(&mut linker, get_wasi_impl)?;
    wasmtime_wasi::bindings::random::random::add_to_linker_get_host(&mut linker, get_wasi_impl)?;
    wasmtime_wasi::bindings::random::insecure::add_to_linker_get_host(&mut linker, get_wasi_impl)?;
    wasmtime_wasi::bindings::random::insecure_seed::add_to_linker_get_host(
        &mut linker,
        get_wasi_impl,
    )?;
    wasmtime_wasi::bindings::cli::stdin::add_to_linker_get_host(&mut linker, get_wasi_impl)?;
    wasmtime_wasi::bindings::cli::stdout::add_to_linker_get_host(&mut linker, get_wasi_impl)?;
    wasmtime_wasi::bindings::cli::stderr::add_to_linker_get_host(&mut linker, get_wasi_impl)?;
    wasmtime_wasi::bindings::cli::terminal_input::add_to_linker_get_host(
        &mut linker,
        get_wasi_impl,
    )?;
    wasmtime_wasi::bindings::cli::terminal_output::add_to_linker_get_host(
        &mut linker,
        get_wasi_impl,
    )?;
    wasmtime_wasi::bindings::cli::terminal_stdin::add_to_linker_get_host(
        &mut linker,
        get_wasi_impl,
    )?;
    wasmtime_wasi::bindings::cli::terminal_stdout::add_to_linker_get_host(
        &mut linker,
        get_wasi_impl,
    )?;
    wasmtime_wasi::bindings::cli::terminal_stderr::add_to_linker_get_host(
        &mut linker,
        get_wasi_impl,
    )?;
    wasmtime_wasi::bindings::cli::exit::add_to_linker_get_host(
        &mut linker,
        &wasmtime_wasi::bindings::cli::exit::LinkOptions::default(),
        get_wasi_impl,
    )?;

    // We're going to have a custom impl, instead of the WasiImpl(T) derived one, so instead of using the closure
    // that gets us a WasiImpl(T), we'll use our own T
    //
    // wasmtime_wasi::bindings::cli::environment::add_to_linker_get_host(&mut linker, closure)?;
    //
    //
    wasmtime_wasi::bindings::cli::environment::add_to_linker_get_host(&mut linker, get_ctx)?;

    // Add host-backed support for the `retrieve` interface to the linker
    bindings::example::reconciler::retrieve::add_to_linker(&mut linker, |ctx| ctx)
        .context("failed to link reconciler")?;

    // Instantiate the component
    let instance = bindings::Reconciler::instantiate_async(&mut store, &component, &linker)
        .await
        .context("Failed to instantiate the reconciler world")?;

    Ok((store, instance))
}

// call the reconcile function
async fn call_reconcile(
    store: &mut Store<Ctx>,
    instance: &Reconciler,
    input_json: String,
) -> std::result::Result<ReconcileResult, ReconcileError> {
    // Call the reconcile function
    let result = instance
        .call_reconcile(store, &input_json)
        .await
        .map_err(|e| ReconcileError {
            code: 500,
            message: format!("Failed to call reconcile: {}", e),
        })??;

    Ok(result)
}

#[tokio::main]
async fn main() -> Result<()> {
    let wasm_path = PathBuf::from(
        std::env::var_os("GUEST_WASM_PATH")
            .context("missing/invalid path to WebAssembly module (env: GUEST_WASM_PATH)")?,
    );

    // Input JSON
    //let input_json = r#"{"apiVersion":"topo.kubenet.dev/v1alpha1","kind":"Topology","metadata":{"name":"kubenet","namespace":"default"},"spec":{"defaults":{"type":"7220ixr-d3l","provider":"srlinux.nokia.com","version":"24.7.2"},"nodes":[{"name":"node1"},{"name":"node2"}],"links":[{"endpoints":[{"node":"node1","port":1,"endpoint":1},{"node":"node2","port":1,"endpoint":1}]}]}}"#.to_string();
    let input_json = r#"{"apiVersion":"topo.kubenet.dev/v1alpha1","kind":"Topology","metadata":{"name":"kubenet","namespace":"default"},"spec":{"defaults":{"type":"7220ixr-d3l","provider":"srlinux.nokia.com","version":"24.7.2"},"nodes":[{"name":"node1"},{"name":"node3"}],"links":[{"endpoints":[{"node":"node1","port":1,"endpoint":1},{"node":"node2","port":1,"endpoint":1}]}]}}"#.to_string();

    //load the instance
    let (mut store, instance) = load_reconciler_instance(wasm_path)
        .await
        .map_err(|e| anyhow::anyhow!("Error loading reconciler instance: {}", e))?;

    // Measure time taken to run the instance 10 times
    let start = Instant::now();

    for i in 0..10 {
        println!("Running iteration: {}", i + 1);
        // Measure iteration time
        let iteration_start = Instant::now();
        match call_reconcile(&mut store, &instance, input_json.clone()).await {
            Ok(result) => {
                let iteration_duration = iteration_start.elapsed();
                println!(
                    "Reconcile Iteration {} succeeded with output: {:#?}",
                    i, result
                );
                println!(
                    "Reconcile Iteration {} elapsed time {:?}",
                    i, iteration_duration
                );
            }
            Err(e) => {
                let iteration_duration = iteration_start.elapsed();
                eprintln!("Reconcile Iteration {} failed: {}", i, e);
                println!(
                    "Reconcile Iteration {} elapsed time {:?}",
                    i, iteration_duration
                );
            }
        }
    }

    let duration = start.elapsed();
    println!("Time taken for 10 iterations: {:?}", duration);

    Ok(())
}

/// Utility function for helping get around issues with rustc inference
///
/// see: https://github.com/bytecodealliance/wasmtime/blob/40eea8ee4c4d19f80f790c3ad4d9c4f0bf6aec55/crates/wasi/src/lib.rs#L431
fn type_annotate<T: WasiView, F>(val: F) -> F
where
    F: Fn(&mut T) -> WasiImpl<&mut T>,
{
    val
}

/// Utility function for helping get around issues with rustc inference,
/// but this time exposing just the pointer itself
///
/// see: https://github.com/bytecodealliance/wasmtime/blob/40eea8ee4c4d19f80f790c3ad4d9c4f0bf6aec55/crates/wasi/src/lib.rs#L431
fn type_annotate_plain<T: WasiView, F>(val: F) -> F
where
    F: Fn(&mut T) -> &mut T,
{
    val
}
